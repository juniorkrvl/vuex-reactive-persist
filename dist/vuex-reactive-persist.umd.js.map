{"version":3,"file":"vuex-reactive-persist.umd.js","sources":["../storage.js","../index.js"],"sourcesContent":["export default class Storage {\n  /**\n   * Creates a new instance of Storage\n   * @param {*Object} options {\n   *    storage: Use custom storage. Must have get/set methods accepting key as parameter.\n   *    reducer: Reduces the value to string,\n   *    parser: Parses the value from string\n   * }\n   */\n  constructor({ storage, reducer, parser }) {\n    this.reducer = reducer || (v => JSON.stringify(v));\n    this.parser = parser || (v => JSON.parse(v));\n    this.previusValue = {};\n    this.watchers = {};\n\n    this.storage = this.storage || {\n      getItem: key => window.localStorage[key],\n      setItem: (key, val) => window.localStorage[(key, val)]\n    };\n\n    // watch every 1000s\n    setInterval(this._callWatchers, 1000);\n  }\n\n  // Call every watcher that has changed values\n  _callWatchers() {\n    Object.keys(this.watchers).forEach(key => {\n      if (this.previusValue[key] !== this.storage.getItem(key)) {\n        this.watchers[key].forEach(f => f());\n      }\n    });\n  }\n\n  /**\n   * Gets a value from local-storage by key\n   * @param {*String} key Key name\n   * @param {*Any} def Default value\n   */\n  get(key) {\n    const val = this.parser(this.storage.getItem(key));\n    this.previusValue[key] = val || this.previusValue[key];\n    return this.previusValue[key];\n  }\n\n  /**\n   * Sets a value to local storage\n   * @param {*String} key Key name\n   * @param {*Any} val Value to store\n   */\n  set(key, val) {\n    this.previusValue[key] = this.reducer(val);\n    this.storage.setItem(key, this.previusValue[key]);\n  }\n\n  /**\n   * Adds watcher for value change of a key\n   * @param {*String} key\n   * @param {*Function} callback\n   */\n  on(key, callback) {\n    if (callback && callback instanceof Function) {\n      this.watchers[key].push(callback);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a watcher\n   * @param {*String} key\n   * @param {*Function} callback\n   */\n  off(key, callback) {\n    const index = this.watchers[key].indexOf(callback);\n    if (index < 0) return false;\n    this.watchers.splice(index, 1);\n    return true;\n  }\n}\n","import Storage from './storage';\n\nexport default function(options) {\n  options = options || {};\n  const key = options.key || 'vuex';\n  const storage = new Storage(options);\n\n  // filters the mutation type\n  const filter =\n    options.filter ||\n    (type => {\n      return !options.mutations || options.mutations.indexOf(type) >= 0;\n    });\n\n  // replace the current state with new state from storage\n  const replaceState = store => {\n    store.replaceState(Object.assign({}, store.state, storage.get(key)));\n  };\n\n  // find changes between previous and current state and callback watches\n  const invokeWatchers = store => {\n    const prev = storage.get();\n    const paths = options.paths || Object.keys(store.state);\n    return paths.filter(path => {\n      if (prev[path] === store.state[path]) return false;\n      options.watch[path] &&\n        options.watch[path](state[path], prev[path], store);\n      return true;\n    });\n  };\n\n  return function(store) {\n    // restore state\n    replaceState(store);\n    options.initialized && options.initialized(store);\n\n    // watch storage value change\n    storage.watch(key, () => {\n      invokeWatchers(store);\n      replaceState(store);\n    });\n\n    store.subscribe(({ type }, state) => {\n      // check if mutation type should be considered\n      if (!filter(type, payload)) return;\n      // find current changes\n      const changes = invokeWatchers(store);\n      // save only on change\n      if (changes.length) {\n        storage.set(options.paths ? pick(state, options.paths) : state);\n      }\n    });\n  };\n}\n\n/**\n * Pick all values specified by te paths and returns an array\n * @param {*Object} object Object to use\n * @param {*Array} paths List of paths to pick\n */\nexport function pick(object, paths) {\n  let list = [];\n  paths.forEach(key => {\n    if (object.hasOwnProperty(key)) {\n      list.push(object[key]);\n    }\n  });\n  return list;\n}\n"],"names":["Storage","ref","parser","reducer","v","JSON","stringify","parse","previusValue","watchers","storage","this","key","window","localStorage","val","_callWatchers","keys","forEach","getItem","f","get","set","setItem","on","callback","Function","push","off","index","indexOf","splice","options","const","filter","type","mutations","replaceState","store","Object","assign","state","invokeWatchers","prev","paths","path","watch","initialized","subscribe","object","list","payload","length","hasOwnProperty"],"mappings":"qLAAe,IAAMA,EASnB,SAAYC,OAAoBC,gBACzBC,4BAAsBC,UAAKC,KAAKC,UAAUF,SAC1CF,OAASA,YAAWE,UAAKC,KAAKE,MAAMH,SACpCI,qBACAC,iBAEAC,QAAUC,KAAKD,2BACTE,UAAOC,OAAOC,aAAaF,qBAC1BA,EAAKG,UAAQF,OAAOC,aAAcC,iBAIlCJ,KAAKK,cAAe,yBAIlCA,2CACSC,KAAKN,KAAKF,UAAUS,iBAAQN,GAC7BD,EAAKH,aAAaI,KAASD,EAAKD,QAAQS,QAAQP,MAC7CH,SAASG,GAAKM,iBAAQE,UAAKA,qBAUtCC,aAAIT,OACIG,EAAMJ,KAAKT,OAAOS,KAAKD,QAAQS,QAAQP,gBACxCJ,aAAaI,GAAOG,GAAOJ,KAAKH,aAAaI,GAC3CD,KAAKH,aAAaI,gBAQ3BU,aAAIV,EAAKG,QACFP,aAAaI,GAAOD,KAAKR,QAAQY,QACjCL,QAAQa,QAAQX,EAAKD,KAAKH,aAAaI,iBAQ9CY,YAAGZ,EAAKa,YACFA,GAAYA,aAAoBC,iBAC7BjB,SAASG,GAAKe,KAAKF,IACjB,gBAUXG,aAAIhB,EAAKa,OACDI,EAAQlB,KAAKF,SAASG,GAAKkB,QAAQL,WACrCI,EAAQ,UACPpB,SAASsB,OAAOF,EAAO,IACrB,IC1EI,SAASG,GAEtBC,IAAMrB,GADNoB,EAAUA,OACUpB,KAAO,OACrBF,EAAU,IAAIV,EAAQgC,GAGtBE,EACJF,EAAQE,iBACPC,UACSH,EAAQI,WAAaJ,EAAQI,UAAUN,QAAQK,IAAS,GAI9DE,WAAeC,GACnBA,EAAMD,aAAaE,OAAOC,UAAWF,EAAMG,MAAO/B,EAAQW,IAAIT,MAI1D8B,WAAiBJ,GACrBL,IAAMU,EAAOjC,EAAQW,MAErB,OADcW,EAAQY,OAASL,OAAOtB,KAAKqB,EAAMG,QACpCP,gBAAOW,GAClB,OAAIF,EAAKE,KAAUP,EAAMG,MAAMI,KAC/Bb,EAAQc,MAAMD,IACZb,EAAQc,MAAMD,GAAMJ,MAAMI,GAAOF,EAAKE,GAAOP,IACxC,MAIX,OAAO,SAASA,GAEdD,EAAaC,GACbN,EAAQe,aAAef,EAAQe,YAAYT,GAG3C5B,EAAQoC,MAAMlC,aACZ8B,EAAeJ,GACfD,EAAaC,KAGfA,EAAMU,mBAAW/C,EAAUwC,OAkBVQ,EACfC,EAjBKhB,SAAaiB,UAEFT,EAAeJ,GAEnBc,QACV1C,EAAQY,IAAIU,EAAQY,OAWPK,EAXoBR,EAYnCS,KAZ0ClB,EAAQY,MAahD1B,iBAAQN,GACRqC,EAAOI,eAAezC,IACxBsC,EAAKvB,KAAKsB,EAAOrC,MAGdsC,GAlBwDT"}