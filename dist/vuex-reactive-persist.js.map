{"version":3,"file":"vuex-reactive-persist.js","sources":["../node_modules/dotty/lib/index.js","../storage.js","../index.js"],"sourcesContent":["//\n// Dotty makes it easy to programmatically access arbitrarily nested objects and\n// their properties.\n//\n\n//\n// `object` is an object, `path` is the path to the property you want to check\n// for existence of.\n//\n// `path` can be provided as either a `\"string.separated.with.dots\"` or as\n// `[\"an\", \"array\"]`.\n//\n// Returns `true` if the path can be completely resolved, `false` otherwise.\n//\n\nvar exists = module.exports.exists = function exists(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    return Object.hasOwnProperty.apply(object, [key]);\n  } else {\n    return exists(object[key], path);\n  }\n};\n\n//\n// These arguments are the same as those for `exists`.\n//\n// The return value, however, is the property you're trying to access, or\n// `undefined` if it can't be found. This means you won't be able to tell\n// the difference between an unresolved path and an undefined property, so you \n// should not use `get` to check for the existence of a property. Use `exists`\n// instead.\n//\n\nvar get = module.exports.get = function get(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (path.length === 0) {\n    return object[key];\n  }\n\n  if (path.length) {\n    return get(object[key], path);\n  }\n};\n\n//\n// Arguments are similar to `exists` and `get`, with the exception that path\n// components are regexes with some special cases. If a path component is `\"*\"`\n// on its own, it'll be converted to `/.*/`.\n//\n// The return value is an array of values where the key path matches the\n// specified criterion. If none match, an empty array will be returned.\n//\n\nvar search = module.exports.search = function search(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (key === \"*\") {\n    key = \".*\";\n  }\n\n  if (typeof key === \"string\") {\n    key = new RegExp(key);\n  }\n\n  if (path.length === 0) {\n    return Object.keys(object).filter(key.test.bind(key)).map(function(k) { return object[k]; });\n  } else {\n    return Array.prototype.concat.apply([], Object.keys(object).filter(key.test.bind(key)).map(function(k) { return search(object[k], path); }));\n  }\n};\n\n//\n// The first two arguments for `put` are the same as `exists` and `get`.\n//\n// The third argument is a value to `put` at the `path` of the `object`.\n// Objects in the middle will be created if they don't exist, or added to if\n// they do. If a value is encountered in the middle of the path that is *not*\n// an object, it will not be overwritten.\n//\n// The return value is `true` in the case that the value was `put`\n// successfully, or `false` otherwise.\n//\n\nvar put = module.exports.put = function put(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    object[key] = value;\n  } else {\n    if (typeof object[key] === \"undefined\") {\n      object[key] = {};\n    }\n\n    if (typeof object[key] !== \"object\" || object[key] === null) {\n      return false;\n    }\n\n    return put(object[key], path, value);\n  }\n};\n\n//\n// `remove` is like `put` in reverse!\n//\n// The return value is `true` in the case that the value existed and was removed\n// successfully, or `false` otherwise.\n//\n\nvar remove = module.exports.remove = function remove(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    if (!Object.hasOwnProperty.call(object, key)) {\n      return false;\n    }\n\n    delete object[key];\n\n    return true;\n  } else {\n    return remove(object[key], path, value);\n  }\n};\n\n//\n// `deepKeys` creates a list of all possible key paths for a given object.\n//\n// The return value is always an array, the members of which are paths in array\n// format. If you want them in dot-notation format, do something like this:\n//\n// ```js\n// dotty.deepKeys(obj).map(function(e) {\n//   return e.join(\".\");\n// });\n// ```\n//\n// *Note: this will probably explode on recursive objects. Be careful.*\n//\n\nvar deepKeys = module.exports.deepKeys = function deepKeys(object, prefix) {\n  if (typeof prefix === \"undefined\") {\n    prefix = [];\n  }\n\n  var keys = [];\n\n  for (var k in object) {\n    if (!Object.hasOwnProperty.call(object, k)) {\n      continue;\n    }\n\n    keys.push(prefix.concat([k]));\n\n    if (typeof object[k] === \"object\" && object[k] !== null) {\n      keys = keys.concat(deepKeys(object[k], prefix.concat([k])));\n    }\n  }\n\n  return keys;\n};\n","import dotty from 'dotty';\n\nexport default class Storage {\n  constructor({ key, storage, reducer, parser }) {\n    this.key = key || 'vuex';\n    this.previousValue = '';\n    this.watchers = [];\n\n    this.reducer = reducer || JSON.stringify;\n    this.parser = parser || JSON.parse;\n    this.storage = storage || {\n      getItem: k => window.localStorage[k],\n      setItem: (k, v) => window.localStorage[k] = v\n    };\n\n    // watch every 1000s for changed values\n    setInterval(() => {\n      if (this.previousValue !== this.storage.get(this.key)) {\n        this.watchers.forEach(f => f());\n      }\n    }, 1000);\n  }\n\n  getState() {\n    try {\n      this.previousValue = this.storage.getItem(this.key);\n      return this.parser(this.previousValue);\n    } catch (err) {\n      this.storage.setItem(this.key, '');\n      return null;\n    }\n  }\n\n  setState(val) {\n    try {\n      this.previousValue = this.reducer(val);\n    } finally {\n      this.storage.setItem(this.key, this.previousValue);\n    }\n  }\n\n  on(callback) {\n    if (callback && callback instanceof Function) {\n      this.watchers.push(callback)\n      return true\n    }\n    return false\n  }\n\n  off(callback) {\n    const index = this.watchers.indexOf(callback)\n    if (index < 0) return false\n    this.watchers.splice(index, 1)\n    return true\n  }\n}\n","import dotty from 'dotty';\nimport Storage from './storage';\n\nexport default function(options) {\n  options = options || {};\n  const {mutations, paths, watch} = options;\n  const storage = new Storage(options);\n\n  // make options paths available\n  function initializeStorage() {\n    const val = storage.getState() || {};\n    (paths || []).forEach(key => {\n      if (!dotty.exists(val, key)) {\n        dotty.put(val, key, null);\n      }\n    });\n    storage.setState(val);\n  }\n\n  // filters the mutation type\n  const filter =\n    options.filter || (type => !mutations || mutations.indexOf(type) >= 0);\n\n  // replace the current state with new state from storage\n  const replaceState = store => {\n    const savedState = storage.getState();\n    if (!savedState) return;\n    store.replaceState(Object.assign(store.state, savedState));\n  }\n\n  // find changes between previous and current state and callback watches\n  const invokeWatchers = (store, state) => {\n    let hasChange = false;\n    state = state || store.state;\n    const prevState = storage.getState() || {};\n    (paths || dotty.deepKeys(state)).forEach(path => {\n      const stateVal = dotty.get(state, path);\n      const savedVal = dotty.get(prevState, path);\n      if (stateVal === savedVal) return;\n      hasChange = true;\n      if (options.watch && options.watch[path]) {\n        options.watch[path](stateVal, savedVal, store);\n      }\n    })\n    return hasChange;\n  }\n\n  return function(store) {\n    // restore state\n    replaceState(store);\n    initializeStorage();\n    options.initialized && options.initialized(store);\n\n    // watch storage value change\n    storage.on(() => {\n      invokeWatchers(store);\n      replaceState(store);\n    })\n\n    store.subscribe(({ type, payload }, state) => {\n      // check if mutation type should be considered\n      if (!filter(type, payload)) return;\n      // find current changes\n      const hasChange = invokeWatchers(store, state);\n      // save only on change\n      if (!hasChange) return;\n      let picked = state;\n      if (options.paths) {\n        picked = {};\n        options.paths.forEach(key => {\n          const val = dotty.get(state, key);\n          dotty.put(picked, key, val);\n        })\n      }\n      storage.setState(picked);\n    })\n  }\n}\n"],"names":["module","exists","object","path","split","Array","length","key","slice","shift","Object","hasOwnProperty","apply","get","search","RegExp","keys","filter","test","bind","map","k","prototype","concat","put","value","remove","call","deepKeys","prefix","push","Storage","ref","storage","reducer","parser","previousValue","watchers","JSON","stringify","parse","window","localStorage","v","this","forEach","f","getState","getItem","err","setItem","setState","val","on","callback","Function","off","index","indexOf","splice","options","mutations","paths","type","replaceState","store","const","savedState","assign","state","invokeWatchers","let","hasChange","prevState","dotty","stateVal","savedVal","watch","initialized","subscribe","picked"],"mappings":"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"}