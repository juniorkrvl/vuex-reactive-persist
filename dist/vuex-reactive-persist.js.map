{"version":3,"file":"vuex-reactive-persist.js","sources":["../node_modules/dotty/lib/index.js","../src/storage.js","../src/index.js"],"sourcesContent":["//\n// Dotty makes it easy to programmatically access arbitrarily nested objects and\n// their properties.\n//\n\n//\n// `object` is an object, `path` is the path to the property you want to check\n// for existence of.\n//\n// `path` can be provided as either a `\"string.separated.with.dots\"` or as\n// `[\"an\", \"array\"]`.\n//\n// Returns `true` if the path can be completely resolved, `false` otherwise.\n//\n\nvar exists = module.exports.exists = function exists(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    return Object.hasOwnProperty.apply(object, [key]);\n  } else {\n    return exists(object[key], path);\n  }\n};\n\n//\n// These arguments are the same as those for `exists`.\n//\n// The return value, however, is the property you're trying to access, or\n// `undefined` if it can't be found. This means you won't be able to tell\n// the difference between an unresolved path and an undefined property, so you \n// should not use `get` to check for the existence of a property. Use `exists`\n// instead.\n//\n\nvar get = module.exports.get = function get(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (path.length === 0) {\n    return object[key];\n  }\n\n  if (path.length) {\n    return get(object[key], path);\n  }\n};\n\n//\n// Arguments are similar to `exists` and `get`, with the exception that path\n// components are regexes with some special cases. If a path component is `\"*\"`\n// on its own, it'll be converted to `/.*/`.\n//\n// The return value is an array of values where the key path matches the\n// specified criterion. If none match, an empty array will be returned.\n//\n\nvar search = module.exports.search = function search(object, path) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return;\n  }\n\n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return;\n  }\n\n  if (key === \"*\") {\n    key = \".*\";\n  }\n\n  if (typeof key === \"string\") {\n    key = new RegExp(key);\n  }\n\n  if (path.length === 0) {\n    return Object.keys(object).filter(key.test.bind(key)).map(function(k) { return object[k]; });\n  } else {\n    return Array.prototype.concat.apply([], Object.keys(object).filter(key.test.bind(key)).map(function(k) { return search(object[k], path); }));\n  }\n};\n\n//\n// The first two arguments for `put` are the same as `exists` and `get`.\n//\n// The third argument is a value to `put` at the `path` of the `object`.\n// Objects in the middle will be created if they don't exist, or added to if\n// they do. If a value is encountered in the middle of the path that is *not*\n// an object, it will not be overwritten.\n//\n// The return value is `true` in the case that the value was `put`\n// successfully, or `false` otherwise.\n//\n\nvar put = module.exports.put = function put(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    object[key] = value;\n  } else {\n    if (typeof object[key] === \"undefined\") {\n      object[key] = {};\n    }\n\n    if (typeof object[key] !== \"object\" || object[key] === null) {\n      return false;\n    }\n\n    return put(object[key], path, value);\n  }\n};\n\n//\n// `remove` is like `put` in reverse!\n//\n// The return value is `true` in the case that the value existed and was removed\n// successfully, or `false` otherwise.\n//\n\nvar remove = module.exports.remove = function remove(object, path, value) {\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!(path instanceof Array) || path.length === 0) {\n    return false;\n  }\n  \n  path = path.slice();\n\n  var key = path.shift();\n\n  if (typeof object !== \"object\" || object === null) {\n    return false;\n  }\n\n  if (path.length === 0) {\n    if (!Object.hasOwnProperty.call(object, key)) {\n      return false;\n    }\n\n    delete object[key];\n\n    return true;\n  } else {\n    return remove(object[key], path, value);\n  }\n};\n\n//\n// `deepKeys` creates a list of all possible key paths for a given object.\n//\n// The return value is always an array, the members of which are paths in array\n// format. If you want them in dot-notation format, do something like this:\n//\n// ```js\n// dotty.deepKeys(obj).map(function(e) {\n//   return e.join(\".\");\n// });\n// ```\n//\n// *Note: this will probably explode on recursive objects. Be careful.*\n//\n\nvar deepKeys = module.exports.deepKeys = function deepKeys(object, prefix) {\n  if (typeof prefix === \"undefined\") {\n    prefix = [];\n  }\n\n  var keys = [];\n\n  for (var k in object) {\n    if (!Object.hasOwnProperty.call(object, k)) {\n      continue;\n    }\n\n    keys.push(prefix.concat([k]));\n\n    if (typeof object[k] === \"object\" && object[k] !== null) {\n      keys = keys.concat(deepKeys(object[k], prefix.concat([k])));\n    }\n  }\n\n  return keys;\n};\n","import dotty from 'dotty';\n\nexport default class Storage {\n  constructor({ key, storage, reducer, parser, disableWatch }) {\n    this.key = key || 'vuex';\n    this.previousValue = '';\n    this.watchers = [];\n\n    this.reducer = reducer || JSON.stringify;\n    this.parser = parser || JSON.parse;\n    this.storage = storage || {\n      getItem: k => window.localStorage[k],\n      setItem: (k, v) => window.localStorage[k] = v\n    };\n\n    // watch every 1000s for changed values\n    if (disableWatch) {\n      setInterval(() => {\n        if (this.previousValue !== this.storage.get(this.key)) {\n          this.watchers.forEach(f => f());\n        }\n      }, 1000);\n    }\n  }\n\n  getState() {\n    try {\n      this.previousValue = this.storage.getItem(this.key);\n      return this.parser(this.previousValue);\n    } catch (err) {\n      this.storage.setItem(this.key, '');\n      return null;\n    }\n  }\n\n  setState(val) {\n    try {\n      this.previousValue = this.reducer(val);\n    } finally {\n      this.storage.setItem(this.key, this.previousValue);\n    }\n  }\n\n  on(callback) {\n    if (callback && callback instanceof Function) {\n      this.watchers.push(callback)\n      return true\n    }\n    return false\n  }\n\n  off(callback) {\n    const index = this.watchers.indexOf(callback)\n    if (index < 0) return false\n    this.watchers.splice(index, 1)\n    return true\n  }\n}\n","import dotty from 'dotty';\nimport Storage from './storage';\n\nexport default function(options) {\n  options = options || {};\n  let {mutations, filter, paths, watch} = options;\n  const storage = new Storage(options);\n\n  // make options paths available\n  function initializeStorage() {\n    const val = storage.getState() || {};\n    (paths || []).forEach(key => {\n      if (!dotty.exists(val, key)) {\n        dotty.put(val, key, null);\n      }\n    });\n    storage.setState(val);\n  }\n\n  // filters the mutation type\n  filter = filter || (x => !mutations || mutations.indexOf(x) >= 0);\n\n  // replace the current state with new state from storage\n  const replaceState = store => {\n    const savedState = storage.getState();\n    if (!savedState) return;\n    store.replaceState(Object.assign(store.state, savedState));\n  }\n\n  // find changes between previous and current state and callback watches\n  const invokeWatchers = (store, state) => {\n    let hasChange = false;\n    state = state || store.state;\n    const prevState = storage.getState() || {};\n    (paths || dotty.deepKeys(state)).forEach(path => {\n      const stateVal = dotty.get(state, path);\n      const savedVal = dotty.get(prevState, path);\n      if (stateVal === savedVal) return;\n      hasChange = true;\n      if (options.watch && options.watch[path]) {\n        options.watch[path](stateVal, savedVal, store);\n      }\n    })\n    return hasChange;\n  }\n\n  return function(store) {\n    // restore state\n    replaceState(store);\n    initializeStorage();\n    options.initialized && options.initialized(store);\n\n    // watch storage value change\n    storage.on(() => {\n      invokeWatchers(store);\n      replaceState(store);\n    })\n\n    store.subscribe((mutation, state) => {\n      // check if mutation type should be considered\n      if (!filter(mutation.type || mutation)) return;\n      // find current changes\n      const hasChange = invokeWatchers(store, state);\n      // save only on change\n      if (!hasChange) return;\n      let picked = state;\n      if (options.paths) {\n        picked = {};\n        options.paths.forEach(key => {\n          const val = dotty.get(state, key);\n          dotty.put(picked, key, val);\n        })\n      }\n      storage.setState(picked);\n    })\n  }\n}\n"],"names":["module","exists","object","path","split","Array","length","key","slice","shift","Object","hasOwnProperty","apply","get","search","RegExp","keys","filter","test","bind","map","k","prototype","concat","put","value","remove","call","deepKeys","prefix","push","Storage","ref","storage","reducer","parser","disableWatch","previousValue","watchers","JSON","stringify","parse","window","localStorage","v","this","forEach","f","getState","getItem","err","setItem","setState","val","on","callback","Function","off","index","indexOf","splice","options","mutations","paths","x","const","replaceState","store","savedState","assign","state","invokeWatchers","let","hasChange","prevState","dotty","stateVal","savedVal","watch","initialized","subscribe","mutation","type","picked"],"mappings":"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"}